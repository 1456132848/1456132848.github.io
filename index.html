<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人博客">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/26/单例模式的多种形式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林明星">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/26/单例模式的多种形式/" class="post-title-link" itemprop="url">单例模式的多种形式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-26 14:27:56 / 修改时间：16:14:36" itemprop="dateCreated datePublished" datetime="2019-07-26T14:27:56+08:00">2019-07-26</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单例模式的多种形式"><a href="#单例模式的多种形式" class="headerlink" title="单例模式的多种形式"></a>单例模式的多种形式</h1><h2 id="一、懒汉模式-线程不安全（适用单线程情况）"><a href="#一、懒汉模式-线程不安全（适用单线程情况）" class="headerlink" title="一、懒汉模式 - 线程不安全（适用单线程情况）"></a>一、懒汉模式 - 线程不安全（适用单线程情况）</h2><p>###实现类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line">    private static LazySingleton single;</span><br><span class="line"></span><br><span class="line">    public LazySingleton() &#123;</span><br><span class="line">        System.out.println(&quot;当前线程名称： &quot; + Thread.currentThread().getName() + &quot;\t 我是构造方法...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static LazySingleton getInstance() &#123;</span><br><span class="line">        if(single == null)&#123;</span><br><span class="line">            single = new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;对象地址：&quot; + single);</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">###单线程测试类：</span><br></pre></td></tr></table></figure>
<p>public class Test {<br>    public static void main(String[] args) {<br>        for (int i = 0; i &lt; 10; i++) {<br>           LazySingleton.getInstance();<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###单线程测试结果</span><br><span class="line"></span><br><span class="line">	当前线程名称： main	 我是构造方法...</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@6fdb1f78</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@6fdb1f78</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@6fdb1f78</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@6fdb1f78</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@6fdb1f78</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@6fdb1f78</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@6fdb1f78</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@6fdb1f78</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@6fdb1f78</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@6fdb1f78</span><br><span class="line"></span><br><span class="line">###多线程测试类</span><br></pre></td></tr></table></figure></p>
<p>public class Test {<br>    public static void main(String[] args) {<br>        for (int i = 0; i &lt; 10; i++) {<br>           new Thread(LazySingleton :: getInstance,”线程” + i).start();<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">###多线程测试结果</span><br><span class="line"></span><br><span class="line">	当前线程名称： 线程0	 我是构造方法...</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@11cbdc81</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@11cbdc81</span><br><span class="line">	当前线程名称： 线程2	 我是构造方法...</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@12d7c574</span><br><span class="line">	当前线程名称： 线程1	 我是构造方法...</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">###结论：</span><br><span class="line">	在单线程环境下，此方法是没有问题的，只会创建唯一一个对象。</span><br><span class="line">	但是在多线程环境下，由于getInstance()方法线程不安全，在同一时间，有多条线程执行此方法，会导致LazySafeSingleton类实例化多次。</span><br><span class="line">	</span><br><span class="line">## 一、懒汉模式 - 线程安全（适用单线程、多线程情况）</span><br><span class="line"></span><br><span class="line">###分析：</span><br><span class="line"></span><br><span class="line">	实现思路：</span><br><span class="line">	 1、私有化构造方法</span><br><span class="line">	 2、创建全局共享私有变量，用来存储唯一实例</span><br><span class="line">	 3、提供一个静态的公共方法，并且使用synchronized修饰，以控制多线程情况，用于外部获取实例对象</span><br><span class="line"> ---	</span><br><span class="line">	</span><br><span class="line">###实现类：</span><br></pre></td></tr></table></figure></p>
<p>public class LazySingleton {<br>    private static LazySingleton single;</p>
<pre><code>public LazySingleton() {
    System.out.println(&quot;当前线程名称： &quot; + Thread.currentThread().getName() + &quot;\t 我是构造方法...&quot;);
}

public synchronized static LazySingleton getInstance() {
    if(single == null){
        single = new LazySingleton();
    }
    System.out.println(&quot;对象地址：&quot; + single);
    return single;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">### 测试类</span><br><span class="line">同上</span><br><span class="line"></span><br><span class="line">### 单线程/多线程测试结果</span><br><span class="line"></span><br><span class="line">	当前线程名称： 线程0	 我是构造方法...</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	对象地址：com.example.demo.LazySingleton@21bd5c97</span><br><span class="line">	</span><br><span class="line">### 结论</span><br><span class="line">	无论单线程还是多线程环境，获取的都是同一个对象，所以此方式在单、多线程下都没有问题。</span><br><span class="line">	</span><br><span class="line">## 双重校验锁模式	</span><br><span class="line"></span><br><span class="line">### 实现类</span><br></pre></td></tr></table></figure></p>
<p>public class DCLSingleton {<br>    private volatile static DCLSingleton single;</p>
<pre><code>public DCLSingleton() {
    System.out.println(&quot;当前线程名称： &quot; + Thread.currentThread().getName() + &quot;\t 我是构造方法...&quot;);
}

public synchronized static DCLSingleton getInstance() {
    if(single == null){
        synchronized (DCLSingleton.class){
            if(single == null){
                single = new DCLSingleton();
            }
        }
    }
    System.out.println(&quot;对象地址：&quot; + single);
    return single;
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 测试类与结果与 “懒汉模式--线程安全” 方式相同</span><br><span class="line"></span><br><span class="line">### 结论：</span><br><span class="line">	1、在私有变量上面加了volatile关键字。 原因是：dclSingleton = new DCLSingleton();编译成字节码后分为三个步骤：</span><br><span class="line">		a. 为 dclSingleton 分配内存空间</span><br><span class="line">		b. 初始化 dclSingleton</span><br><span class="line">		b. 将 dclSingleton 执行分配的内存地址</span><br><span class="line">	由于jvm具有指令重排的特性，在多线程环境下就可能会出现一个线程获取到的实例还未被初始化的情况。例如：线程T1执行了1和3，此时线程T2调用 getDclSingleton() 方法后发现 dclSingleton 不为空，因此会返回 dclSingleton，但是此时 dclSingleton 还未被初始化。因此在声明静态私有变量时添加volatile关键字保证jvm无法进行指令重排，从而解决上述问题。</span><br><span class="line">	</span><br><span class="line">	2、原来的同步方法变成了同步块。</span><br><span class="line">	</span><br><span class="line">	 if(single == null)&#123;</span><br><span class="line">        synchronized (DCLSingleton.class)&#123;</span><br><span class="line">            if(single == null)&#123;</span><br><span class="line">                single = new DCLSingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    a、此种同步方法，可以提高并发效率，因为同步的仅仅是实例化对象的那一部分代码，在对象已经实例化之后，剩余的线程可以并发执行。</span><br><span class="line">    b、synchronized内再次进行single == null的判断是因为，当多个线程执行到此同步块时，防止重复实例化。外层的single == null是为了提高并发效率，当single已经实例化后，就可以异步执行后面的内容了。</span><br><span class="line">    </span><br><span class="line">## 饿汉式-线程安全</span><br><span class="line"></span><br><span class="line">### 实现类</span><br></pre></td></tr></table></figure>
<p>public class HungrySingleton {<br>    private static HungrySingleton single = new HungrySingleton();</p>
<pre><code>public HungrySingleton() {
    System.out.println(&quot;当前线程名称： &quot; + Thread.currentThread().getName() + &quot;\t 我是构造方法...&quot;);
}

public static HungrySingleton getInstance() {
    System.out.println(&quot;对象地址：&quot; + single);
    return single;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 测试类与结果</span><br><span class="line">与 “懒汉模式--线程安全” 方式相同</span><br><span class="line"></span><br><span class="line">### 结论</span><br><span class="line">饿汉模式与懒汉模式的区别在于：</span><br><span class="line"></span><br><span class="line">	饿汉模式在类加载的时候就创建好了实例对象并赋予全局共享变量single。而懒汉模式则是在调用获取实例对象的方法时才开始实例化。</span><br><span class="line">	而且饿汉模式是线程安全的，无论是单线程，还是多线程，只会实例化一次。</span><br><span class="line">	所以饿汉模式会导致资源浪费，即使不调用方法，也会实例化。</span><br><span class="line"></span><br><span class="line">## 静态内部类方式</span><br><span class="line"></span><br><span class="line">### 实现类</span><br></pre></td></tr></table></figure></p>
<p>public class InnerClazzSingleton {</p>
<pre><code>private InnerClazzSingleton(){}

public static InnerClazzSingleton getInstance() {
    return InnerClassSingletonHolder.SINGLE;
}

private static class InnerClassSingletonHolder{
    private static final InnerClazzSingleton SINGLE = new InnerClazzSingleton();
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 测试类与结果</span><br><span class="line">与 “懒汉模式--线程安全” 方式相同</span><br><span class="line"></span><br><span class="line">### 结论</span><br><span class="line">	此方式的优点在于：</span><br><span class="line">		1、和饿汉模式一样线程安全，无论单线程多线程，均只实例化一次</span><br><span class="line">		2、由于静态内部类在调用时才加载，所以不会像饿汉模式那样浪费资源，调用getInstance方法时才开始实例化</span><br><span class="line">		</span><br><span class="line">### 枚举类</span><br></pre></td></tr></table></figure></p>
<p>public enum EnumSingleton {<br>    INSTANCE;</p>
<pre><code>private String name;

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}
</code></pre><p>}<br><code>`</code></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><pre><code>枚举类一般会有多个实例化对象，可以看作是多例模式。
在枚举类中若只有1个实例化对象，则即可以看作是单例模式。
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>1、实现思路：
    a、私有化构造方法
    b、创建全局共享私有变量，用来存储唯一实例
    c、提供一个静态的公共方法，用于外部获取实例对象
2、
    a. 懒汉式-线程不安全
    线程不安全；具有延迟加载解决资源的特点；
    b. 懒汉式-线程安全
    对1进行改造——在全局访问点处添加同步机制。能保证线程安全，虽说多线程能保证一致性，但是无法保证并发性
    c. 双重锁校验式-线程安全
    对2进行改造，以求提高并发性，使用volatile 修饰静态实例变量，同步前和同步后均需要校验实例变量是否为空。线程安全
    d. 饿汉式-线程安全
    对1进行改造，在使用前即会创建实例变量。全局只会创建一次，因此能保证线程安全，但是会造成资源浪费的问题
    e. 静态内部类-线程安全
    对4进行改造，利用静态内部类使用时才会加载的特性将 实例变量的使用权 和 构造权 解耦。线程安全
    f. 枚举类-线程安全
    线程安全，多适用于单元素场景    
</code></pre><hr>
<p>参考文章：<br>    <a href="!https://juejin.im/post/5d396492f265da1b94218e54">你真的懂单例模式吗</a>    </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/java连接ftp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林明星">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/18/java连接ftp/" class="post-title-link" itemprop="url">java连接ftp</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-18 22:37:53 / 修改时间：22:49:11" itemprop="dateCreated datePublished" datetime="2019-07-18T22:37:53+08:00">2019-07-18</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、java连接Ftp方法工具类"><a href="#一、java连接Ftp方法工具类" class="headerlink" title="一、java连接Ftp方法工具类"></a>一、java连接Ftp方法工具类</h1><pre><code>package com.yunkai.psbmngboot.utils;

import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPFile;
import org.apache.commons.net.ftp.FTPReply;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.List;

/**
 * @Description TODO
 * @Author linmingxing
 * @Date 2019/6/5 下午3:24
 **/
public class FtpUtil {

    private static Logger logger = LoggerFactory.getLogger(FtpUtil.class);

    /**
     * 获取FTPClient对象
     * @param ftpHost 服务器IP
     * @param ftpPort 服务器端口号
     * @param ftpUserName 用户名
     * @param ftpPassword 密码
     * @return FTPClient
     */
    public static FTPClient getFTPClient(String ftpHost, int ftpPort, String ftpUserName, String ftpPassword) {
        FTPClient ftp = null;
        try {
            ftp = new FTPClient();
            ftp.setConnectTimeout(300000);
            ftp.setControlEncoding(&quot;UTF-8&quot;);
            // 连接FPT服务器,设置IP及端口
            logger.info(&quot;开始连接connect&quot;+ftpHost+&quot;===&quot;+ftpPort+&quot;===&quot;+ftpUserName+&quot;====&quot;+ftpPassword+&quot;=====&quot;);
            ftp.connect(ftpHost, ftpPort);
            // 设置用户名和密码
            logger.info(&quot;开始登录&quot;);
            ftp.login(ftpUserName, ftpPassword);
            // 设置连接超时时间,5000毫秒

            // 设置中文编码集，防止中文乱码
            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                logger.info(&quot;未连接到FTP，用户名或密码错误&quot;);
                ftp.disconnect();
            } else {
                logger.info(&quot;FTP连接成功&quot;);
            }
        } catch (SocketException e) {
            logger.info(&quot;FTP的IP地址可能错误，请正确配置&quot;,e);
        } catch (IOException e) {
            logger.info(&quot;FTP的端口错误,请正确配置&quot;,e);
        }
        return ftp;
    }

    /**
     * 关闭FTP方法
     * @param ftp
     * @return
     */
    public static boolean closeFTP(FTPClient ftp){

        try {
            ftp.logout();
            logger.info(&quot;FTP关闭成功&quot;);
        } catch (Exception e) {
            logger.error(&quot;FTP关闭失败&quot;);
        }finally{
            if (ftp.isConnected()) {
                try {
                    ftp.disconnect();
                } catch (IOException ioe) {
                    logger.error(&quot;FTP关闭失败&quot;);
                }
            }
        }
        return false;
    }

    /**
     * 下载FTP下指定文件
     * @param ftp FTPClient对象
     * @param filePath FTP文件路径
     * @param fileName 文件名
     * @param downPath 下载保存的目录
     * @return
     */
    public static File downLoadFTP(FTPClient ftp, String filePath, String fileName,
                               String downPath) {
        // 默认失败
        boolean flag;

        try {
            // 跳转到文件目录
            ftp.changeWorkingDirectory(filePath);
            FTPFile[] files = ftp.listFiles();
            for (FTPFile file : files) {
                // 取得指定文件并下载
                if (file.getName().equals(fileName)) {
                    File downFile = new File(downPath + file.getName());
                    OutputStream out = new FileOutputStream(downFile);
                    // 绑定输出流下载文件,需要设置编码集，不然可能出现文件为空的情况
                    flag = ftp.retrieveFile(new String(file.getName().getBytes(&quot;UTF-8&quot;),&quot;UTF-8&quot;), out);
                    out.flush();
                    out.close();
                    if(flag){
                        logger.info(&quot;下载成功&quot;);
                        return downFile;
                    }else{
                        logger.error(&quot;下载失败&quot;);
                        return null;
                    }
                }
            }
        } catch (Exception e) {
            logger.error(&quot;下载失败&quot;);
        }
        return null;
    }

    /**
     * FTP文件上传工具类
     * @param ftp
     * @param filePath
     * @param ftpPath
     * @return
     */
    public static boolean uploadFile(FTPClient ftp,String filePath,String ftpPath){
        boolean flag = false;
        InputStream in = null;
        try {
            // 设置PassiveMode传输
//            ftp.enterLocalPassiveMode();
            //设置二进制传输，使用BINARY_FILE_TYPE，ASC容易造成文件损坏
            ftp.setFileType(FTPClient.BINARY_FILE_TYPE);
            //判断FPT目标文件夹时候存在不存在则创建
            if(!ftp.changeWorkingDirectory(ftpPath)){
                ftp.makeDirectory(ftpPath);
            }
            //跳转目标目录
            ftp.changeWorkingDirectory(ftpPath);

            //上传文件
            File file = new File(filePath);
            in = new FileInputStream(file);
            String tempName = ftpPath+File.separator+file.getName();
            flag = ftp.storeFile(new String (tempName.getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;),in);
            if(flag){
                logger.info(&quot;上传成功&quot;);
            }else{
                logger.error(&quot;上传失败&quot;);
            }
        } catch (Exception e) {
            logger.error(&quot;上传失败&quot;,e);
        }finally{
            try {
                in.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                logger.error(&quot;上传失败&quot;,e);
            }
        }
        return flag;
    }


    /**
     * FPT上文件的复制
     * @param ftp  FTPClient对象
     * @param olePath 原文件地址
     * @param newPath 新保存地址
     * @param fileName 文件名
     * @return
     */
    public boolean copyFile(FTPClient ftp, String olePath, String newPath,String fileName) {
        boolean flag = false;

        try {
            // 跳转到文件目录
            ftp.changeWorkingDirectory(olePath);
            //设置连接模式，不设置会获取为空
            ftp.enterLocalPassiveMode();
            // 获取目录下文件集合
            FTPFile[] files = ftp.listFiles();
            ByteArrayInputStream  in = null;
            ByteArrayOutputStream out = null;
            for (FTPFile file : files) {
                // 取得指定文件并下载
                if (file.getName().equals(fileName)) {

                    //读取文件，使用下载文件的方法把文件写入内存,绑定到out流上
                    out = new ByteArrayOutputStream();
                    ftp.retrieveFile(new String(file.getName().getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;), out);
                    in = new ByteArrayInputStream(out.toByteArray());
                    //创建新目录
                    ftp.makeDirectory(newPath);
                    //文件复制，先读，再写
                    //二进制
                    ftp.setFileType(FTPClient.BINARY_FILE_TYPE);
                    flag = ftp.storeFile(newPath+File.separator+(new String(file.getName().getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;)),in);
                    out.flush();
                    out.close();
                    in.close();
                    if(flag){
                        logger.info(&quot;转存成功&quot;);
                    }else{
                        logger.error(&quot;复制失败&quot;);
                    }
                }
            }
        } catch (Exception e) {
            logger.error(&quot;复制失败&quot;);
        }
        return flag;
    }

    /**
     * 实现文件的移动，这里做的是一个文件夹下的所有内容移动到新的文件，
     * 如果要做指定文件移动，加个判断判断文件名
     * 如果不需要移动，只是需要文件重命名，可以使用ftp.rename(oleName,newName)
     * @param ftp
     * @param oldPath
     * @param newPath
     * @return
     */
    public boolean moveFile(FTPClient ftp,String oldPath,String newPath){
        boolean flag = false;

        try {
            ftp.changeWorkingDirectory(oldPath);
            ftp.enterLocalPassiveMode();
            //获取文件数组
            FTPFile[] files = ftp.listFiles();
            //新文件夹不存在则创建
            if(!ftp.changeWorkingDirectory(newPath)){
                ftp.makeDirectory(newPath);
            }
            //回到原有工作目录
            ftp.changeWorkingDirectory(oldPath);
            for (FTPFile file : files) {

                //转存目录
                flag = ftp.rename(new String(file.getName().getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;), newPath+File.separator+new String(file.getName().getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;));
                if(flag){
                    logger.info(file.getName()+&quot;移动成功&quot;);
                }else{
                    logger.error(file.getName()+&quot;移动失败&quot;);
                }
            }
        } catch (Exception e) {
            logger.error(&quot;移动文件失败&quot;,e);
        }
        return flag;
    }

    /**
     * 删除FTP上指定文件夹下文件及其子文件方法，添加了对中文目录的支持
     * @param ftp FTPClient对象
     * @param FtpFolder 需要删除的文件夹
     * @return
     */
    public boolean deleteByFolder(FTPClient ftp,String FtpFolder){
        boolean flag = false;
        try {
            ftp.changeWorkingDirectory(new String(FtpFolder.getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;));
            ftp.enterLocalPassiveMode();
            FTPFile[] files = ftp.listFiles();
            for (FTPFile file : files) {
                //判断为文件则删除
                if(file.isFile()){
                    ftp.deleteFile(new String(file.getName().getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;));
                }
                //判断是文件夹
                if(file.isDirectory()){
                    String childPath = FtpFolder + File.separator+file.getName();
                    //递归删除子文件夹
                    deleteByFolder(ftp,childPath);
                }
            }
            //循环完成后删除文件夹
            flag = ftp.removeDirectory(new String(FtpFolder.getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;));
            if(flag){
                logger.info(FtpFolder+&quot;文件夹删除成功&quot;);
            }else{
                logger.error(FtpFolder+&quot;文件夹删除成功&quot;);
            }

        } catch (Exception e) {
            logger.error(&quot;删除失败&quot;,e);
        }
        return flag;

    }

    /**
     * 遍历解析文件夹下所有文件
     * @param folderPath 需要解析的的文件夹
     * @param ftp FTPClient对象
     * @return
     */
    public List&lt;String&gt; readFileByFolder(FTPClient ftp, String folderPath){
        List&lt;String&gt; jsonList = new ArrayList&lt;&gt;();
        boolean flage = false;
        try {
//            ftp.changeWorkingDirectory(new String(folderPath.getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;));
            //设置FTP连接模式
//            ftp.enterLocalPassiveMode();
            //获取指定目录下文件文件对象集合
            FTPFile files[] = ftp.listFiles();
            InputStream in = null;
            BufferedReader reader = null;
            for (FTPFile file : files) {
                //判断为txt文件则解析
                if(file.isFile()){
                    String fileName = file.getName();
                    if(fileName.endsWith(&quot;.txt&quot;)){
                        in = ftp.retrieveFileStream(new String(file.getName().getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;));
                        reader = new BufferedReader(new InputStreamReader(in, &quot;UTF-8&quot;));
                        String temp;
                        StringBuffer buffer = new StringBuffer();
                        while((temp = reader.readLine())!=null){
                            buffer.append(temp);
                        }
                        if(reader!=null){
                            reader.close();
                        }
                        if(in!=null){
                            in.close();
                        }
                        //ftp.retrieveFileStream使用了流，需要释放一下，不然会返回空指针
                        ftp.completePendingCommand();
                        //这里就把一个txt文件完整解析成了个字符串，就可以调用实际需要操作的方法
                        System.out.println(buffer.toString());
                        jsonList.add(buffer.toString());
                    }
                }
            }

        } catch (Exception e) {
            logger.error(&quot;文件解析失败&quot;,e);
        }

        return jsonList;

    }




    public static void main(String[] args) throws IOException {
//        FTPClient ftp = FtpUtil.getFTPClient(&quot;101.132.130.77&quot;, 21, &quot;ftpuser&quot;,&quot;taoyeti520&quot;);
//        test.downLoadFTP(ftp, &quot;/file&quot;, &quot;你好.jpg&quot;, &quot;C:\\下载&quot;);
        //test.copyFile(ftp, &quot;/file&quot;, &quot;/txt/temp&quot;, &quot;你好.txt&quot;);
        //test.moveFile(ftp, &quot;/file&quot;, &quot;/txt/temp&quot;);
        //test.deleteByFolder(ftp, &quot;/txt&quot;);
//        test.readFileByFolder(ftp, &quot;/home/ftpuser/&quot;);
//        test.closeFTP(ftp);

    }


}


</code></pre><h1 id="二、-注意事项"><a href="#二、-注意事项" class="headerlink" title="二、 注意事项"></a>二、 注意事项</h1><pre><code>1、一般的在liunx服务器上的ftp，需要通过enterLocalPassiveMode()方法设置为被动模式，在window服务器上的ftp，一般不用设置，默认为主动模式。连接模式如果没有设置正确的话，获取文件的方法会假死，其他操作会报错。

2、获取指定目录文件下的方法listFiles(&quot;path&quot;)的参数为服务器上设置的ftp的根路径（用终端连接到ftp后，输入命令pwd后得到的就是ftp的根路径）
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/05/sublime填坑之旅/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林明星">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/05/sublime填坑之旅/" class="post-title-link" itemprop="url">sublime填坑之旅</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-05 16:20:18 / 修改时间：16:21:21" itemprop="dateCreated datePublished" datetime="2019-07-05T16:20:18+08:00">2019-07-05</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>1、复制完以后，粘贴的时候按下 ctrl+shift+v 就可以使代码整齐粘贴不错位。否则从第二行开始会错位
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/05/跨域问题详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林明星">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/05/跨域问题详解/" class="post-title-link" itemprop="url">跨域问题详解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-05 14:15:35" itemprop="dateCreated datePublished" datetime="2019-07-05T14:15:35+08:00">2019-07-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-08 15:36:05" itemprop="dateModified" datetime="2019-07-08T15:36:05+08:00">2019-07-08</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、跨域问题简述"><a href="#一、跨域问题简述" class="headerlink" title="一、跨域问题简述"></a>一、跨域问题简述</h1><p>引起跨域的根本原因：浏览器的同源策略。</p>
<pre><code>因为存在浏览器同源策略，所以才会有跨域问题。所谓同源是指：域名、协议、端口相同。
</code></pre><p><img src="/2019/07/05/跨域问题详解/跨域图片.png" alt></p>
<p>另外，同源策略又分为以下两种：</p>
<pre><code>1、DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。

2、XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。
</code></pre><h1 id="二、为什么要有跨域限制"><a href="#二、为什么要有跨域限制" class="headerlink" title="二、为什么要有跨域限制"></a>二、为什么要有跨域限制</h1><p>如果没有 DOM 同源策略，也就是说不同域的 iframe 之间可以相互访问，那么黑客可以这样进行攻击：</p>
<pre><code>1、做一个假网站，里面用 iframe 嵌套一个银行网站 http://mybank.com。
2、把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。
3、这时如果用户输入账号密码，我们的主网站可以跨域访问到 http://mybank.com 的 dom 节点，就可以拿到用户的账户密码了    
</code></pre><p>如果没有XMLHttpRequest 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击：</p>
<pre><code>1、用户登录了自己的银行页面 http://mybank.com，http://mybank.com 向用户的 cookie 中添加用户标识。
2、用户浏览了恶意页面 http://evil.com，执行了页面中的恶意 AJAX 请求代码。
3、http://evil.com 向 http://mybank.com 发起 AJAX HTTP 请求，请求会默认把 http://mybank.com 对应 cookie 也同时发送过去。
4、银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据。此时数据就泄露了。
5、而且由于 Ajax 在后台执行，用户无法感知这一过程。
</code></pre><h1 id="三、跨域的解决方法"><a href="#三、跨域的解决方法" class="headerlink" title="三、跨域的解决方法"></a>三、跨域的解决方法</h1><h2 id="3-1-后端解决"><a href="#3-1-后端解决" class="headerlink" title="3.1 后端解决"></a>3.1 后端解决</h2><h3 id="3-1-1-对于springMvc框架："><a href="#3-1-1-对于springMvc框架：" class="headerlink" title="3.1.1 对于springMvc框架："></a>3.1.1 对于springMvc框架：</h3><pre><code>新建一个filter，在response中添加允许跨域的响应头。

public class SimpleCORSFilter implements Filter{  

    @Override  
    public void destroy() {  

    }  

    @Override  
    public void doFilter(ServletRequest req, ServletResponse res,  
            FilterChain chain) throws IOException, ServletException {  
            HttpServletResponse response = (HttpServletResponse) res;  
            //设置允许跨域的请求源
            response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  
            //设置允许跨域的请求方法
            response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;);  
            //设置缓存的最大时间
            response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);  
            //设置响应头
            response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;content-type&quot;);
            chain.doFilter(req, res);  

    }  

    @Override  
    public void init(FilterConfig arg0) throws ServletException {  

    }  

}

另外在web.xml中注册该filter
&lt;filter&gt;  
  &lt;filter-name&gt;cors&lt;/filter-name&gt;  
  &lt;filter-class&gt;com.ssm.web.filter.SimpleCORSFilter&lt;/filter-class&gt;  
&lt;/filter&gt;  
&lt;filter-mapping&gt;  
  &lt;filter-name&gt;cors&lt;/filter-name&gt;  
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  
&lt;/filter-mapping&gt;
</code></pre><h3 id="3-1-2-对于springBoot框架："><a href="#3-1-2-对于springBoot框架：" class="headerlink" title="3.1.2 对于springBoot框架："></a>3.1.2 对于springBoot框架：</h3><p>添加以下配置即可：</p>
<pre><code>package com.yunkai.psbmngboot.config;
import com.yunkai.psbmngboot.interceptor.WebInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.*;

/**
 * CorsConfig
 *
 * @author gsong
 * @date 2019/05/14 00:53
 * 跨域
 */
@Configuration
public class WebConfigurer extends WebMvcConfigurationSupport {

    @Autowired
    private WebInterceptor webInterceptor;

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping(&quot;/**&quot;)
                .allowedOrigins(&quot;*&quot;)
                //允许携带cookies
                .allowCredentials(true)
                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)
                .maxAge(36000);
        System.out.println(&quot;xxx&quot;);
    }
 }

 注意：跨域请求时，前端ajax请求时需要设置withCredentials: true,才能够将cookies带上。
</code></pre><h2 id="3-2-前端解决"><a href="#3-2-前端解决" class="headerlink" title="3.2 前端解决"></a>3.2 前端解决</h2><h2 id="3-2-1-vue框架解决方法"><a href="#3-2-1-vue框架解决方法" class="headerlink" title="3.2.1 vue框架解决方法"></a>3.2.1 vue框架解决方法</h2><p>在config/index.js中的dev配置中添加proxyTable,’/api’是一个拦截表示，在开发环境中请求时需要在url中统一加上’/api’, pathRewrite 会在请求时去除/api，target是需要跨域的请求地址：</p>
<pre><code>dev: {
    env: require(&apos;./dev.env&apos;),
    host: &apos;localhost&apos;,
    port: 9520,
    autoOpenBrowser: false,
    autoOpenPage: &apos;/login&apos;,
    assetsSubDirectory: &apos;static&apos;,
    assetsPublicPath: &apos;/&apos;,
    proxyTable: {
      &apos;/api&apos;: {
        target: &apos;http://localhost:9999&apos;,
        changeOrigin: true,
        pathRewrite: {
          &apos;^/api&apos;: &apos;/&apos;
        }
      }
    },
    cssSourceMap: false
}
</code></pre><h2 id="3-2-2-nginx解决跨域问题"><a href="#3-2-2-nginx解决跨域问题" class="headerlink" title="3.2.2 nginx解决跨域问题"></a>3.2.2 nginx解决跨域问题</h2><p>在开发环境中请求时需要在url中统一加上’/api’, proxy_pass是需要跨域的请求地址。在server中配置：</p>
<pre><code>location / {
    proxy_pass http://localhost:81;
    proxy_redirect default;
}

 #添加访问目录为/apis的代理配置
location /apis {
    rewrite  ^/apis/(.*)$ /$1 break;
    proxy_pass   http://localhost:82;
}
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/27/Elasticsearch的安装与使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林明星">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/27/Elasticsearch的安装与使用/" class="post-title-link" itemprop="url">Elasticsearch的安装与使用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-27 09:35:58 / 修改时间：17:14:55" itemprop="dateCreated datePublished" datetime="2019-05-27T09:35:58+08:00">2019-05-27</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><pre><code>1、分布式的实时文件存储，每个字段都被索引并可被搜索
2、分布式的实时分析搜索引擎
3、可以扩展到上百台服务器，处理PB级结构化或非结构化数据
</code></pre><p>Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。这种理解数据的方式与以往完全不同，这也是Elasticsearch能够执行复杂的全文搜索的原因之一。</p>
<p>ELasticsearch使用Javascript对象符号(JavaScript Object Notation)，也就是JSON，作为文档序列化格式。</p>
<p>在Elasticsearch中将对象转化为JSON并做索引要比在表结构中做相同的事情简单的多。    </p>
<h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><h2 id="2、1安装"><a href="#2、1安装" class="headerlink" title="2、1安装"></a>2、1安装</h2><p>安装前提需要安装java环境。<br>elastic search下载地址：<a href="https://www.elastic.co/cn/products/elasticsearch（点击右侧download）" target="_blank" rel="noopener">https://www.elastic.co/cn/products/elasticsearch（点击右侧download）</a><br>（推荐安装谷歌浏览器的一个插件elasticsearch-head，它是Es的一个客户端工具）。</p>
<h2 id="2、2运行"><a href="#2、2运行" class="headerlink" title="2、2运行"></a>2、2运行</h2><p>安装完成后执行命令</p>
<pre><code>./bin/elasticsearch，
</code></pre><p>如果想在后台以守护进程模式运行，添加-d参数</p>
<p>打开另一个终端测试，输入命令：</p>
<pre><code>curl &apos;http://localhost:9200/?pretty&apos;
</code></pre><p>看到以下信息，说明es启动成功，正常运行：</p>
<pre><code>{
   &quot;status&quot;: 200,
   &quot;name&quot;: &quot;Shrunken Bones&quot;,
   &quot;version&quot;: {
      &quot;number&quot;: &quot;1.4.0&quot;,
      &quot;lucene_version&quot;: &quot;4.10&quot;
   },
   &quot;tagline&quot;: &quot;You Know, for Search&quot;
}
</code></pre><h2 id="2、3关闭"><a href="#2、3关闭" class="headerlink" title="2、3关闭"></a>2、3关闭</h2><p>可以使用Ctrl-C快捷键终止，或者你可以调用shutdown API来关闭：</p>
<pre><code>curl -XPOST &apos;http://localhost:9200/_shutdown&apos;    
</code></pre><h1 id="三、交互方式"><a href="#三、交互方式" class="headerlink" title="三、交互方式"></a>三、交互方式</h1><p>其他所有程序语言都可以使用RESTful API，通过9200端口的与Elasticsearch进行通信，你可以使用你喜欢的WEB客户端，事实上，如你所见，你甚至可以通过curl命令与Elasticsearch通信<br>向Elasticsearch发出的请求的组成部分与其它普通的HTTP请求是一样的：</p>
<pre><code>curl -X&lt;VERB&gt; &apos;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&apos; -d &apos;&lt;BODY&gt;&apos;
</code></pre><p>举例说明，为了计算集群中的文档数量，我们可以这样做：</p>
<pre><code>curl -H &quot;Content-Type: application/json&quot; -XGET &apos;http://localhost:9200/_count?pretty&apos; -d &apos;
{
    &quot;query&quot;: {
        &quot;match_all&quot;: {}
    }
}
&apos;
</code></pre><p>上面的请求会得到如下的JSON格式的响应主体：    </p>
<pre><code>{
  &quot;count&quot; : 8874,
  &quot;_shards&quot; : {
    &quot;total&quot; : 1,
    &quot;successful&quot; : 1,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  }
}
</code></pre><p>es官网中没有指定请求头，-H “Content-Type: application/json” ,这在高版本的es中会报错。</p>
<h1 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h1><p>在Elasticsearch中，文档归属于一种类型(type),而这些类型存在于索引(index)中，我们可以画一些简单的对比图来类比传统关系型数据库：</p>
<pre><code>Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns
Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields
</code></pre><p>Elasticsearch集群可以包含多个索引(indices)（数据库），每一个索引可以包含多个类型(types)（表），每一个类型包含多个文档(documents)（行），然后每个文档包含多个字段(Fields)（列）。</p>
<h2 id="4-1-操作索引"><a href="#4-1-操作索引" class="headerlink" title="4.1 操作索引"></a>4.1 操作索引</h2><p>新增索引（info-test为索引名称）</p>
<pre><code>curl -XPUT &quot;localhost:9200/info-test
</code></pre><p>删除索引</p>
<pre><code>curl -XDELETE &apos;http://localhost:9200/info-test&apos;
</code></pre><h2 id="4-2-操作文档"><a href="#4-2-操作文档" class="headerlink" title="4.2 操作文档"></a>4.2 操作文档</h2><p>插入文档（即插入一行数据，people是索引类型，相当于一个表，1是文档id，在没有申明id的情况下，向索引中插入文档，ES会随机生成一个ID）</p>
<pre><code>curl -H &quot;Content-Type: application/json&quot; -XPUT &quot;localhost:9200/info-test/people/1&quot; -d &apos;{&quot;title&quot;:&quot;123&quot;}&apos;
</code></pre><p>删除文档</p>
<pre><code>curl -H &quot;Content-Type: application/json&quot; -XDELETE &quot;localhost:9200/info-test/people/1&quot;
</code></pre><h2 id="4-3-查询"><a href="#4-3-查询" class="headerlink" title="4.3 查询"></a>4.3 查询</h2><p>Es有各种方式查询数据，可以在elasticsearch-head等客户端工具实践操作，这里不再赘述。</p>
<blockquote>
<p>参考：<a href="https://es.xiaoleilu.com/010_Intro/00_README.html" target="_blank" rel="noopener">Es权威指南</a></p>
<p>参考：<a href="https://blog.csdn.net/wyl9527/article/details/76039686/" target="_blank" rel="noopener">https://blog.csdn.net/wyl9527/article/details/76039686/</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/16/maven知识点小记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林明星">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/16/maven知识点小记/" class="post-title-link" itemprop="url">maven知识点小记</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-16 16:44:46 / 修改时间：17:02:10" itemprop="dateCreated datePublished" datetime="2019-05-16T16:44:46+08:00">2019-05-16</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/maven/" itemprop="url" rel="index"><span itemprop="name">maven</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、maven更换阿里云镜像。"><a href="#一、maven更换阿里云镜像。" class="headerlink" title="一、maven更换阿里云镜像。"></a>一、maven更换阿里云镜像。</h1><p>在maven的setting.xml中的mirrors节点下添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">	&lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">	&lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">	&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">	&lt;mirrorOf&gt;*&lt;/mirrorOf&gt; </span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>
<h1 id="二、使用mvn-site构建项目文档"><a href="#二、使用mvn-site构建项目文档" class="headerlink" title="二、使用mvn site构建项目文档"></a>二、使用mvn site构建项目文档</h1><p>在pom文件中加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;pluginManagement&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.3&lt;/version&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.7&lt;/version&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/pluginManagement&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>在项目根目录下执行mvn-site即可。生成的文档将位于target/site目录下。</p>
<p>在idea中，使用idea自带的maven工具来执行site命令时会报错。原因暂时不明白。在命令行中执行mvn site时也会报一些错误，但是最终结果是build succes。</p>
<h1 id="三、maven依赖下载顺序"><a href="#三、maven依赖下载顺序" class="headerlink" title="三、maven依赖下载顺序"></a>三、maven依赖下载顺序</h1><pre><code>有三个仓库：
    本地仓库
    中央仓库
    远程仓库（可以在pom.xml或者setting.xml中配置）

maven首先在本地仓库中查找，若能找到依赖，则停止查找。
若在本地仓库没找到，则在中央仓库寻找，若找到，则下载至本地，然后停止查找。
若在中央仓库也没找到，并且配置了远程仓库，则在远程仓库寻找，若找到，则停止查找。
若在远程仓库仍然没有找到，则报错。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/圆通开放平台订单对接/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林明星">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/13/圆通开放平台订单对接/" class="post-title-link" itemprop="url">圆通海外G面单订单对接</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-13 15:27:16 / 修改时间：16:12:37" itemprop="dateCreated datePublished" datetime="2019-05-13T15:27:16+08:00">2019-05-13</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/第三方平台对接/" itemprop="url" rel="index"><span itemprop="name">第三方平台对接</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、接口描述"><a href="#一、接口描述" class="headerlink" title="一、接口描述"></a>一、接口描述</h1><pre><code>客户端发起请求后，本接口接收订单信息HTTP请求，解析订单信息XML，并存入圆通系统，下单成功后业务员会在一定时间内带上传统面单上门揽件。请求地址
http://58.32.246.71:8000/overseaOrderServlet
</code></pre><h1 id="二、传输方式"><a href="#二、传输方式" class="headerlink" title="二、传输方式"></a>二、传输方式</h1><pre><code>本文档内描述的接口均采用Http传输协议。 Get请求用于测试是否可以连通圆通接口服务器，在浏览器访问以下相关接口地址，如果返回success则证明接口访问正常。 数据传输必须用post请求。请求参数以及数据处理参见1.1.2和1.1.3.
</code></pre><h1 id="三、报文结构"><a href="#三、报文结构" class="headerlink" title="三、报文结构"></a>三、报文结构</h1><pre><code>参数名称                   说明
logistics_interface     要发送的xml内容（必填）
data_digest             数字签名（必填）
clientId                客户编码（电商标识）（必填）
type                    订单类型（online:在线下单，offline:线下下单）（必填）

logistics_interface表示需要发送的xml内容，比如拉取面单、上传订单等xml报文。 partnerId 表示商家密钥，比如测试环境测试账号K21000119的密钥为123456。 data_digest代表数字签名，签名的原理是对要发送的xml报文字符串加上商家密钥，先进行MD5加密，然后转换成base64字符串，作为数字签名的数据。即： Base64 [ MD5 [ logistics_interface +partnerId ] ] 最后对所有参数的数据内容进行url编码。
</code></pre><h1 id="四、签名规则"><a href="#四、签名规则" class="headerlink" title="四、签名规则"></a>四、签名规则</h1><pre><code>加密步骤是：
1. 以上XML格式的字符串订单以HTTP POST方式发送，客户端发起请求后，圆通电子面单接口在http response里把电子面单信息同步给客户端。
2. 在POST时用“logistics_interface”字段表示要发送的XML经过URL编码之后的内容；
3. 在POST时用“data_digest”字段进行签名验证。签名使用MD5方式，对logistics_interface的内容进行签名。原理为：通知内容（xml）+partnerId，然后进行MD5，转换为Base64字符串，然后在经过URL编码。
详细解释如下：
         假设xml内容为： &lt;order&gt;&lt;/order&gt;， partnerId为123456
         对xml内容&lt;order&gt;&lt;/order&gt;进行URL编码（字符集UTF-8）为%3Corder%3E%3C%2Forder%3E
         签名内容为&lt;order&gt;&lt;/order&gt;123456，经过md5和base64后为LghTkEmsD2tbQ3fsIBRcBg==
         对签名的字符串进行URL编码，LghTkEmsD2tbQ3fsIBRcBg==的内容变为：LghTkEmsD2tbQ3fsIBRcBg%3D%3D
         最终要发送的数据为：
        logistics_interface=%3Corder%3E%3C%2Forder%3E&amp;data_digest=LghTkEmsD2tbQ3fsIBRcBg%3D%3D&amp;type=online&amp;clientId=ECNAME

总结如下：
a、在POST时用“logistics_interface”字段表示要发送的XML报文经过URL编码后的内容。
b、在POST时用“data_digest”字段进行签名验证。签名使用MD5方式，对logistics_interface的内容进行签名。原理为：通知内容（xml）+partnerId，然后进行MD5，转换为Base64字符串，然后在经过URL编码。
c、假设xml内容为： ， partnerId为123456。对xml内容（）进行URL编码（字符集UTF-8）为%3Corder%3E%3C%2Forder%3E。 签名内容为123456，经过md5和base64后为LghTkEmsD2tbQ3fsIBRcBg== 。对签名的字符串进行URL编码，LghTkEmsD2tbQ3fsIBRcBg==的内容变为：LghTkEmsD2tbQ3fsIBRcBg%3D%3D
d、最终要发送的数据为：logistics_interface=%3Corder%3E%3C%2Forder%3E &amp;data_digest= LghTkEmsD2tbQ3fsIBRcBg%3D%3D &amp;type=offline&amp;clientId=K21000119
</code></pre><h1 id="五、-参数列表"><a href="#五、-参数列表" class="headerlink" title="五、    参数列表"></a>五、    参数列表</h1><p>参见<a href="http://open.yto.net.cn/OpenPlatform/doc" target="_blank" rel="noopener">官方文档</a></p>
<h1 id="六、代码示例"><a href="#六、代码示例" class="headerlink" title="六、代码示例"></a>六、代码示例</h1><pre><code>1、封装请求参数(
图中JSONObject使用的是 
    &lt;dependency&gt;
        &lt;groupId&gt;org.json&lt;/groupId&gt;
        &lt;artifactId&gt;json&lt;/artifactId&gt;
        &lt;version&gt;20180813&lt;/version&gt;
    &lt;/dependency&gt;)
</code></pre><p><a href="http://stleary.github.io/JSON-java/index.html" target="_blank" rel="noopener">org.json文档</a><br><img src="/2019/05/13/圆通开放平台订单对接/img1.png" alt><br>    2、加密后发送请求<br><img src="/2019/05/13/圆通开放平台订单对接/img2.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/08/自动化测试之cucumber/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林明星">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/08/自动化测试之cucumber/" class="post-title-link" itemprop="url">自动化测试之cucumber.md</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-08 14:27:19" itemprop="dateCreated datePublished" datetime="2019-05-08T14:27:19+08:00">2019-05-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-09 15:32:14" itemprop="dateModified" datetime="2019-05-09T15:32:14+08:00">2019-05-09</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>cucumber是BDD(Behavior-driven development，行为驱动开发)的一个自动化测试的副产品。它使用自然语言来描述测试，使得非程序员可以理解他们。Gherkin是这种自然语言测试的简单语法，而Cucumber是可以执行它们的工具。关于BDD有兴趣自行了解。附cucumber<a href="https://cucumber.io/" title="cucumber官网" target="_blank" rel="noopener">官网链接</a>，里面也有关于BDD的信息。<br>cucumber本质上是使用根据正则表达式匹配自然语言，然后依次执行对应的方法，以达到测试的目的。</p>
<h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><pre><code>cucumber支持JDK8，创建一个mvn工程，在pom.xml文件引入以下依赖即可。
另外如果测试框架采用的是junit，则需要多一个cucumber-junit。
如果集成spring,则还需要引入cucumber-spring
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;info.cukes&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;cucumber-java&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.2.4&lt;/version&gt;</span><br><span class="line">     &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;info.cukes&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;cucumber-junit&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.2.4&lt;/version&gt;</span><br><span class="line">     &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;info.cukes&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;cucumber-spring&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.2.4&lt;/version&gt;</span><br><span class="line">     &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<pre><code>也可以根据mvn骨架创建cucumber项目。打开终端，转到要创建项目的目录（比如本文是hellocucumber)，运行以下命令
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> mvn archetype:generate                  </span><br><span class="line">-DarchetypeGroupId=io.cucumber           </span><br><span class="line">-DarchetypeArtifactId=cucumber-archetype </span><br><span class="line">-DarchetypeVersion=2.3.1.2               </span><br><span class="line">-DgroupId=hellocucumber                  </span><br><span class="line">-DartifactId=hellocucumber              </span><br><span class="line">-Dpackage=hellocucumber                  </span><br><span class="line">-Dversion=1.0.0-SNAPSHOT                 </span><br><span class="line">-DinteractiveMode=false</span><br></pre></td></tr></table></figure>
<pre><code>应该得到如下结果:
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Project created from Archetype in dir:   hellocucumber/cucumber</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<pre><code>但是不支持jdk8 U51之后的新版本！每次都报错说&quot;Wrong type at constant pool index&quot;。
</code></pre><h1 id="三、基本语法"><a href="#三、基本语法" class="headerlink" title="三、基本语法"></a>三、基本语法</h1><h2 id="3-1-Gherkin"><a href="#3-1-Gherkin" class="headerlink" title="3.1 Gherkin"></a>3.1 Gherkin</h2><pre><code>Cucumber 执行 .feature 文件，而这些文件包含可执行的规范，用被称为 Gherkin 的语言写成。.featur文件一般放在src/test/resources/[项目名称xxx]目录下或者其子目录下。

Gherkin 是带有一点额外结构的纯文本的英文(或者替他60多种语言). Gherkin 设计为容易被非编程人员学习，但有足够的组织结构来容许简洁的范例描述，以说明大多数实际领域中的业务规则。
下面是一个简单的.feature 文件的例子
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Feature: Refund item</span><br><span class="line"></span><br><span class="line">Scenario: Jeff returns a faulty microwave</span><br><span class="line">    Given Jeff has bought a microwave for $100</span><br><span class="line">    And he has a receipt</span><br><span class="line">    When he returns the microwave</span><br><span class="line">    Then Jeff should be refunded $100</span><br></pre></td></tr></table></figure>
<pre><code>在 Gherkin 中, 每行必须以 Gherkin 关键字开头, 然后跟随有任意的文本。主要的关键字有：
</code></pre><ul>
<li>Feature / 特性</li>
<li>Scenario / 场景</li>
<li>Given, When, Then, And, But (Steps/步骤)</li>
<li>Background / 背景</li>
<li>Scenario Outline / 场景大纲</li>
<li><p>Examples / 示例</p>
<p>  还有其他一些额外的关键字:</p>
</li>
<li><p>“”” (Doc Strings)</p>
</li>
<li>| (Data Tables)</li>
<li>@ (Tags)</li>
<li># Comments</li>
</ul>
<hr>
<h2 id="3-2-Feature-特性"><a href="#3-2-Feature-特性" class="headerlink" title="3.2 Feature / 特性"></a>3.2 Feature / 特性</h2><pre><code>.feature 文件用来描述系统的一个单一特性，或者某个特性的一个独特方面。这仅仅是一个提供软件特性的高级描述的方法，并用于组织相关的场景(scenarios)。
feature有三个基本元素：
1.Feature: 关键字
2.name： 名称, 在同一行
3.description：描述, 可选（但是强烈推荐），可以占据多行   
例如：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Feature: Refund item</span><br><span class="line"></span><br><span class="line">  Sales assistants should be able to refund customers&apos; purchases.</span><br><span class="line">  This is required by the law, and is also essential in order to</span><br><span class="line">  keep customers happy.</span><br><span class="line"></span><br><span class="line">  Rules:</span><br><span class="line">  - Customer must present proof of purchase</span><br><span class="line">  - Purchase must be less than 30 days ago</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-3-Scenario-场景"><a href="#3-3-Scenario-场景" class="headerlink" title="3.3 Scenario / 场景"></a>3.3 Scenario / 场景</h2><pre><code>Scenario 是具体的实例，描述一个业务规则。它由步骤列表组成。
可以有任意多个步骤，但是推荐数量保持在每个场景3-5个步骤。如果太长，他们将丧失作为规范和文档的表单能力。
在作为规范和文档之外，场景也同样是测试。作为一个整体，场景是系统的可执行规范。
场景遵循同样的模式：
1、 描述一个初始化上下文
2、 描述一个时间
3、 描述一个期望的产出
</code></pre><hr>
<h2 id="3-4-Steps-步骤"><a href="#3-4-Steps-步骤" class="headerlink" title="3.4 Steps / 步骤"></a>3.4 Steps / 步骤</h2><pre><code>步骤通常以 Given, When 或 Then 开头。如果有多个 Given 或者 When 步骤连在一
起，可以使用 And 或者 But。Cucumber不区分这些关键字，但是选择正确的关键字对于
场景整体的可读性很重要。
</code></pre><hr>
<h2 id="3-5-Given-假设"><a href="#3-5-Given-假设" class="headerlink" title="3.5 Given / 假设"></a>3.5 Given / 假设</h2><pre><code>Given 步骤用于描述系统的初始化上下文 - 场景的一幕(scene of Scenario)。它通常是某些已经发生在过去的东西。
当cucumber执行 Given 步骤时，它将配置系统到一个定义良好的状态，例如创建并配置对象或者添加数据到测试数据库。
可以有多个 Given 步骤（可以使用 And 或者 But 来变的更可读）
</code></pre><hr>
<h2 id="3-6-Then-那么"><a href="#3-6-Then-那么" class="headerlink" title="3.6 Then / 那么"></a>3.6 Then / 那么</h2><pre><code>Then 步骤用于描述期望的产出，或者结果。
Then 步骤的 步骤定义 应该使用断言来比较实际产出(系统实际行为)和期待产出(步骤所述的系统应有的行为)
</code></pre><hr>
<h2 id="3-7-Background-背景"><a href="#3-7-Background-背景" class="headerlink" title="3.7 Background / 背景"></a>3.7 Background / 背景</h2><pre><code>发现一个feature文件中的所有场景都在重复同样的 Given 步骤。既然它在每个场景
可以将这样的 Given 步骤移动到background中，在第一个场景之前，用一个 Background 块组织他们：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Background:</span><br><span class="line">  Given a $100 microwave was sold on 2015-11-03</span><br><span class="line">  And today is 2015-11-18</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-8-Scenario-Outline-场景大纲"><a href="#3-8-Scenario-Outline-场景大纲" class="headerlink" title="3.8 Scenario Outline / 场景大纲"></a>3.8 Scenario Outline / 场景大纲</h2><pre><code>当有复杂业务规则，带有多个输入或者输出，可以最终创建仅仅是值有差别的多个场景。举个例子:
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Scenario: feeding a small suckler cow</span><br><span class="line">    Given the cow weighs 450 kg</span><br><span class="line">    When we calculate the feeding requirements</span><br><span class="line">    Then the energy should be 26500 MJ</span><br><span class="line">    And the protein should be 215 kg</span><br><span class="line"></span><br><span class="line">Scenario: feeding a medium suckler cow</span><br><span class="line">    Given the cow weighs 500 kg</span><br><span class="line">    When we calculate the feeding requirements</span><br><span class="line">    Then the energy should be 29500 MJ</span><br><span class="line">    And the protein should be 245 kg</span><br><span class="line"></span><br><span class="line"># 还有两个例子 --- 已经令人厌烦了</span><br></pre></td></tr></table></figure>
<pre><code>如果有很多例子，将会很乏味。可以通过使用场景大纲来简化：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Scenario Outline: feeding a suckler cow</span><br><span class="line">    Given the cow weighs &lt;weight&gt; kg</span><br><span class="line">    When we calculate the feeding requirements</span><br><span class="line">    Then the energy should be &lt;energy&gt; MJ</span><br><span class="line">    And the protein should be &lt;protein&gt; kg</span><br><span class="line"></span><br><span class="line">    Examples:</span><br><span class="line">        | weight | energy | protein |</span><br><span class="line">        |    450 |  26500 |     215 |</span><br><span class="line">        |    500 |  29500 |     245 |</span><br><span class="line">        |    575 |  31500 |     255 |</span><br><span class="line">        |    600 |  37000 |     305 |</span><br></pre></td></tr></table></figure>
<pre><code>这更易于阅读。场景大纲步骤中的变量通过使用 &lt; 和 &gt; 来标记。
</code></pre><hr>
<h2 id="3-9-Examples-示例"><a href="#3-9-Examples-示例" class="headerlink" title="3.9 Examples / 示例"></a>3.9 Examples / 示例</h2><pre><code>场景大纲部分总被带有一个或者多个 Examples / 示例 部分，用于包含一个表格。
表格必须有header 行，对应场景大纲步骤中的变量。
下面的每一行将创建一个新的场景，使用变量的值填充。
</code></pre><hr>
<h2 id="3-10-执行步骤"><a href="#3-10-执行步骤" class="headerlink" title="3.10 执行步骤"></a>3.10 执行步骤</h2><pre><code>当cucumber执行场景中的步骤时，它将查找匹配的步骤定义来执行。
步骤定义是带有正则表达式的小段代码。正则表达式用于连接步骤定义到所有匹配的步骤，而代码是cucumber要执行的内容。
例如一下场景：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scenario: Some cukes</span><br><span class="line">    Given I have 48 cukes in my belly</span><br></pre></td></tr></table></figure>
<pre><code>步骤的 I have 48 cukes in my belly 部分（Given关键字后面的文本）将匹配下面的步骤定义：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Given(&quot;I have (\\d+) cukes in my belly&quot;)</span><br><span class="line">public void I_have_cukes_in_my_belly(int cukes)&#123;</span><br><span class="line">    System.out.format(&quot;Cukes: %n\n&quot;, cukes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>当cucumber匹配步骤到一个步骤定义中的正则表达式时，它传递所有捕获组（capture group）的值到步骤定义的参数。捕获组是字符串(即使他们匹配数字如 \d+ )。对于静态类型语言，cucumber将自动转换这些字符串到合适的类型。对于动态类型语言，默认不转换，因为他们没有类型信息。
Cucumber不区分这五个步骤关键字 Given， When， Then， And 和 But。
</code></pre><h1 id="四、实践"><a href="#四、实践" class="headerlink" title="四、实践"></a>四、实践</h1><h2 id="4-1编写-feature文件"><a href="#4-1编写-feature文件" class="headerlink" title="4.1编写.feature文件"></a>4.1编写.feature文件</h2><p><img src="/2019/05/08/自动化测试之cucumber/cucumber1.png" alt="cucumber1"><br>    .features文件一般放在test/resources/features目录下。<br>    图中使用的是中文来编写的，这样写的前提是在首行加上 # language: zh-CN<br>    一个场景为一个执行单位，一般用于测试一个接口。每个步骤都会通过正则匹配一个方法。<br>    步骤写好后，鼠标点击黄色色块上，按下自动提示快捷键，编译器会提示定义step。按提示创建即可。</p>
<h2 id="4-2编写步骤steps类"><a href="#4-2编写步骤steps类" class="headerlink" title="4.2编写步骤steps类"></a>4.2编写步骤steps类</h2><pre><code>如下图：
</code></pre><p><img src="/2019/05/08/自动化测试之cucumber/cucumber2.png" alt="cucumber2"><br>     图中@cucumber.api.java.zh_CN报红，只要将cucumber.api.java.zh_CN删除，重新导入即可。或者将CN改为小写的cn。<br>    steps类一般放在test/java/项目包名/目录下的一个文件夹中。<br>    每个方法中编写测试代码，去测试某个接口。接口的访问可以使用RestTemplate。使用Assert判断接口返回是否与预期的一样。</p>
<pre><code>一个完整的场景，包括以下几个步骤：
1、新建测试数据
2、调用接口进行测试
3、删除测试数据
这样可以重复测试，不会产生多余的测试数据。
</code></pre><h2 id="4-3-启动测试"><a href="#4-3-启动测试" class="headerlink" title="4.3 启动测试"></a>4.3 启动测试</h2><pre><code>启动测试有两种方法，
1、右键.feature文件，选择Debug Feature执行
2、如下图，编写测试类去启动@CucumberOptions注解的features属性对应.feature文件
</code></pre><p><img src="/2019/05/08/自动化测试之cucumber/cucumber3.png" alt="cucumber3"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/01/hexo的安装与使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林明星">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/01/hexo的安装与使用/" class="post-title-link" itemprop="url">Hexo安装与使用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-01 22:47:59" itemprop="dateCreated datePublished" datetime="2019-05-01T22:47:59+08:00">2019-05-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-13 16:18:45" itemprop="dateModified" datetime="2019-05-13T16:18:45+08:00">2019-05-13</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hexo安装与使用"><a href="#Hexo安装与使用" class="headerlink" title="Hexo安装与使用"></a>Hexo安装与使用</h1><h2 id="1、前提条件"><a href="#1、前提条件" class="headerlink" title="1、前提条件"></a>1、前提条件</h2><pre><code>Node.js、git

安装git:
    Windows：下载并安装 [git](https://git-scm.com/download/win)
    Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。
    Linux (Ubuntu, Debian)：sudo apt-get install git-core
    Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core

安装Node.js：
    安装Node.js的最佳方式是使用nvm
    curl方式安装nvm:
        curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh
    wget方式安装nvm:
        wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh
    安装完成后，重启终端并执行下列命令即可安装 Node.js。
        nvm install stable
</code></pre><p>$ nvm install stable</p>
<h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><pre><code>npm install -g hexo-cli
</code></pre><h2 id="3、建站"><a href="#3、建站" class="headerlink" title="3、建站"></a>3、建站</h2><pre><code>在指定文件夹执行以下指令
    1、hexo init
    2、npm install
新建完成后，文件夹目录如下
    .
    ├── _config.yml
    ├── package.json
    ├── scaffolds
    ├── source
    |   ├── _drafts
    |   └── _posts
    └── themes
</code></pre><h3 id="3-1、展示分类菜单"><a href="#3-1、展示分类菜单" class="headerlink" title="3.1、展示分类菜单"></a>3.1、展示分类菜单</h3><pre><code>首先打开主题目录下的config.xml文件，找到menu节点，放开被注释的categories。
再在根目录下执行hexo new page categories，这时source目录下生成categories文件夹，里面有一个index.md文件。修改文件内容为以下即可： 
---
title: categories
date: 2019-05-02 08:36:58
type: categories
---
</code></pre><h3 id="3-2、展示标签菜单"><a href="#3-2、展示标签菜单" class="headerlink" title="3.2、展示标签菜单"></a>3.2、展示标签菜单</h3><pre><code>首先打开主题目录下的config.xml文件，找到menu节点，放开被注释的tags。
再在根目录下执行hexo new page tags，这时source目录下生成tags文件夹，里面有一个index.md文件。修改文件内容为以下即可： 
---
title: tags
date: 2019-05-02 08:36:58
type: tags
---
</code></pre><h2 id="4、写作"><a href="#4、写作" class="headerlink" title="4、写作"></a>4、写作</h2><pre><code>执行命令：
hexo new [layout] &lt;title&gt; 
默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局
</code></pre><h2 id="5、服务器"><a href="#5、服务器" class="headerlink" title="5、服务器"></a>5、服务器</h2><pre><code>Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用
执行：
    npm install hexo-server --save
安装完成后，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器
执行：
    hexo server（简写hexo s）
也可以自定义端口，执行：
    hexo server -p 5000
这样开启的服务器为动态模式。    

执行以下命令为静态模式：
    hexo server -s
在静态模式下，服务器只处理 public 文件夹内的文件，而不会处理文件变动，在执行时，您应该先自行执行 hexo generate（简写hexo g），此模式通常用于生产环境（production mode）下。
</code></pre><h2 id="6、部署"><a href="#6、部署" class="headerlink" title="6、部署"></a>6、部署</h2><pre><code>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。

在部署之前，您必须先在 _config.yml 中修改参数，这里以git为例，将项目部署到git上。
执行： 
    npm install hexo-deployer-git --save
修改配置:
    deploy:
  type: git
  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io
  branch: [branch] #published
  message: [自定义提交信息]

配置完成后，执行以下命令即可：
    hexo deploy（简写hexo d）
</code></pre><p><a href="https://hexo.io/zh-cn/docs/deployment" target="_blank" rel="noopener">hexo官网文档</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/30/cordova与js互调（以信鸽为例）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林明星">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/30/cordova与js互调（以信鸽为例）/" class="post-title-link" itemprop="url">Cordova与原生安卓互相调用（混合app开发）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-30 16:08:37" itemprop="dateCreated datePublished" datetime="2019-04-30T16:08:37+08:00">2019-04-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-15 16:10:41" itemprop="dateModified" datetime="2019-05-15T16:10:41+08:00">2019-05-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/混合app开发/" itemprop="url" rel="index"><span itemprop="name">混合app开发</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、Js调用cordova安卓插件"><a href="#一、Js调用cordova安卓插件" class="headerlink" title="一、Js调用cordova安卓插件"></a>一、Js调用cordova安卓插件</h2><h3 id="1、以集成腾讯信鸽为例"><a href="#1、以集成腾讯信鸽为例" class="headerlink" title="1、以集成腾讯信鸽为例"></a>1、以集成腾讯信鸽为例</h3><pre><code>a、需求：在js中获取原生安卓注册后返回的信鸽token。
b、分析：在安卓端以cordova插件形式暴露一个获取token的方法。在js中使用cordova去调用
c、安卓部分代码实现：
    在安卓中新建GetXingeToken类，并集成CordovaPlugin类，集成实现execute方法，循环获取token，知道token部位null时，返回。
    callbackContext.success(&quot;&quot;)方法表示成功，参数表示成功的信息。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException &#123;</span><br><span class="line">    Object token = MainActivity.token;</span><br><span class="line">    //当信鸽token为null时循环获取，知道token不为null时返回给前台（这种做法会阻塞线程，故改为在js中定时获取token。）</span><br><span class="line">&lt;!--    while(token == null)&#123;</span><br><span class="line">        token = MainActivity.token;</span><br><span class="line">    &#125;--&gt;</span><br><span class="line">    callbackContext.success(token == null ? null : token.toString());</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>打开res下xml目录下的config.xml,添加以下代码。GetXingeToken即是该插件的名称，value是刚才创建的GetXingeToken类的全限定名。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;feature name=&quot;GetXingeToken&quot;&gt;</span><br><span class="line">    &lt;param name=&quot;android-package&quot; value=&quot;org.apache.cordova.xinge.GetXingeToken&quot; /&gt;</span><br><span class="line">    &lt;param name=&quot;onload&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/feature&gt;</span><br></pre></td></tr></table></figure>
<pre><code>d、js部分代码实现
    deviceready是Cordova完全加载后，事件才会触发，这样可以保证
    能够成功的调用Cordova函数。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--document.addEventListener(&quot;deviceready&quot;, onDeviceReady =&gt; &#123;</span><br><span class="line">    //cordova.exec 执行操作</span><br><span class="line">    cordova.exec(function (msg) &#123;</span><br><span class="line">      // alert(&apos;test成功了&apos; + msg)</span><br><span class="line">      console.log(&quot;----XingeToken:&quot; + msg);</span><br><span class="line">      localStorage.setItem(&quot;xingeToken&quot;,msg);</span><br><span class="line">    &#125;, function (msg) &#123;</span><br><span class="line">      // alert(&apos;test失败了&apos;)</span><br><span class="line">    &#125;, &quot;GetXingeToken&quot;, &quot;testAction&quot;, [&apos;传递的参数&apos;]);</span><br><span class="line">&#125;, false);--&gt;</span><br><span class="line"></span><br><span class="line">//因为在执行到这一步的时候，信鸽token可能还没有注册好。所以每隔3秒获取一次token，知道token不为null时为止。</span><br><span class="line">document.addEventListener(&quot;deviceready&quot;, onDeviceReady =&gt; &#123;</span><br><span class="line">    //cordova.exec 执行操作</span><br><span class="line">    var timer = setInterval(() =&gt; &#123;</span><br><span class="line">      cordova.exec(function (msg) &#123;</span><br><span class="line">        // alert(&apos;test成功了&apos; + msg)</span><br><span class="line">        console.log(&quot;----XingeToken:&quot; + msg);</span><br><span class="line">        if(msg != null)&#123;</span><br><span class="line">          clearInterval(timer);</span><br><span class="line">          localStorage.setItem(&quot;xingeToken&quot;,msg);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, function (msg) &#123;</span><br><span class="line">        // alert(&apos;test失败了&apos;)</span><br><span class="line">      &#125;, &quot;GetXingeToken&quot;, &quot;testAction&quot;, [&apos;传递的参数&apos;]);</span><br><span class="line">    &#125;,3000);</span><br><span class="line">  &#125;, false);</span><br></pre></td></tr></table></figure>
<h2 id="二、安卓调用js插件"><a href="#二、安卓调用js插件" class="headerlink" title="二、安卓调用js插件"></a>二、安卓调用js插件</h2><pre><code>a、js端代码：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &lt;!-- android调用js方法 --&gt;</span><br><span class="line">    function showAlert(content)&#123;</span><br><span class="line">        alert(content);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<pre><code>b、安卓端调用代码
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends CordovaActivity &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">            super.onCreate(savedInstanceState);</span><br><span class="line">            // Set by &lt;content src=&quot;index.html&quot; /&gt; in config.xml</span><br><span class="line">            loadUrl(launchUrl);</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10000);</span><br><span class="line">                        runOnUiThread(new Runnable() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void run() &#123;</span><br><span class="line">                                //不能在子线程中执行webview的方法</span><br><span class="line">                                loadUrl(&quot;javascript:showAlert(\&quot;你好\&quot;)&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>在子线程中等待了10秒然后在主线程中去调用js的方是为了让js加载完成后再调用。
</code></pre><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><pre><code>在使用信鸽时遇到过一个需求，需要根据不同种类的消息，跳转至不同的页面，因为时webapp，所以只能再js中控制跳转。当接收到消息并点击后，再receiver中携带通知消息跳转到MainActivity，在MainActivity的onNewIntent方法中使用loadUrl调用js方法，实现跳转。关键代码如下。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">//MessageReceiver方法，继承XGPushBaseReceiver</span><br><span class="line">// 通知点击回调 actionType=1为该消息被清除，actionType=0为该消息被点击。此处不能做点击消息跳转，详细方法请参照官网的Android常见问题文档</span><br><span class="line">    @Override</span><br><span class="line">    public void onNotifactionClickedResult(Context context,</span><br><span class="line">                                           XGPushClickedResult message) &#123;</span><br><span class="line">//        Log.e(&quot;LC&quot;, &quot;+++++++++++++++ 通知被点击 跳转到指定页面。&quot;);</span><br><span class="line">        NotificationManager notificationManager = (NotificationManager) context</span><br><span class="line">                .getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">        notificationManager.cancelAll();</span><br><span class="line">        if (context == null || message == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (message.getActionType() == XGPushClickedResult.NOTIFACTION_CLICKED_TYPE) &#123;</span><br><span class="line">            // 通知在通知栏被点击啦。。。。。</span><br><span class="line">            // APP自己处理点击的相关动作</span><br><span class="line">            // 这个动作可以在activity的onResume也能监听，请看第3点相关内容</span><br><span class="line">            Intent intent = null;</span><br><span class="line">            intent=new Intent(context,MainActivity.class);</span><br><span class="line">            String customContent = message.getCustomContent();</span><br><span class="line">            intent.putExtra(&quot;customContent&quot;,customContent);</span><br><span class="line">            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class="line">            context.startActivity(intent);</span><br><span class="line">        &#125; else if (message.getActionType() == XGPushClickedResult.NOTIFACTION_DELETED_TYPE) &#123;</span><br><span class="line">            // 通知被清除啦。。。。</span><br><span class="line">            // APP自己处理通知被清除后的相关动作</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取自定义key-value</span><br><span class="line">        String customContent = message.getCustomContent();</span><br><span class="line">        if (customContent != null &amp;&amp; customContent.length() != 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                JSONObject obj = new JSONObject(customContent);</span><br><span class="line">                // key1为前台配置的key</span><br><span class="line">                if (!obj.isNull(&quot;message_id&quot;)) &#123;</span><br><span class="line">                    String value = obj.getString(&quot;message_id&quot;);</span><br><span class="line">//                    Log.d(LogTag, &quot;get custom value message_id:&quot; + value);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!obj.isNull(&quot;message_cat&quot;)) &#123;</span><br><span class="line">                    String value = obj.getString(&quot;message_cat&quot;);</span><br><span class="line">//                    Log.d(LogTag, &quot;get custom value message_cat:&quot; + value);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; catch (JSONException e) &#123;</span><br><span class="line">//                Log.d(LogTag,e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//MainActivity方法</span><br><span class="line">@Override</span><br><span class="line">protected void onNewIntent(Intent intent) &#123;</span><br><span class="line">    super.onNewIntent(intent);</span><br><span class="line">    getIntentData(intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void getIntentData(Intent intent) &#123;</span><br><span class="line">    if(intent!=null)&#123;</span><br><span class="line">        Bundle extras = intent.getExtras();</span><br><span class="line">        if(extras != null)&#123;</span><br><span class="line">            Object customContent = extras.get(&quot;customContent&quot;);</span><br><span class="line">            if(customContent != null)&#123;</span><br><span class="line">                loadUrl(&quot;javascript:toInfo(&quot;+customContent+&quot;)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//js方法</span><br><span class="line">function toInfo(customContent) &#123;</span><br><span class="line">    console.log(customContent);</span><br><span class="line">    if(customContent.infoType == &quot;1&quot; || customContent.infoType == &quot;2&quot; || customContent.infoType == &quot;4&quot;)&#123;</span><br><span class="line">      var deviceid = customContent.deviceid;</span><br><span class="line">      var lat = customContent.lat;</span><br><span class="line">      var lon = customContent.lon;</span><br><span class="line">      var time = customContent.time;</span><br><span class="line">      location.href = &quot;file:///android_asset/www/index.html#/location?deviceid=&quot;+deviceid+&quot;&amp;lat=&quot;+lat+&quot;&amp;lon=&quot;+lon+&quot;&amp;time=&quot;+time+&quot;&amp;flag=2&quot;;</span><br><span class="line">    &#125;else if(customContent.infoType = &quot;5&quot;)&#123;</span><br><span class="line">      location.href = &quot;file:///android_asset/www/index.html#/sysInfo&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">林明星</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">林明星</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
